#!/usr/bin/python

################################################################################
# parse-manifest
# Parses the repo manifest for a project and generates code output to execute
# commands across all repositories, such as git commands
################################################################################

import codecs
import copy
import os
import re
import sys

from xml.dom import minidom

# figure out what packages depend on what others
def dependencies(projectroot, projectlist):
    dependmap = {}
    for p in projectlist:
        makelist = codecs.open(projectroot + "/" + str(p) + "/CMakeLists.txt", \
                'r', 'utf-8').read()
        dependmap[p] = []
        # dependent packages are listed
        # find_package<whitespace>(<whitespace>[NAME]<whitespace|)>)
        pattern = re.compile(r"find_package\s*\(\s*?(.*?)[\s)]")
        for match in re.findall(pattern, makelist):
            dependmap[p].append(match)
    # strip out dependencies that aren't in the project list
    dependcopy = copy.deepcopy(dependmap)
    for k, v in dependcopy.items():
        for v1 in v:
            if not v1 in projectlist:
                dependmap[k].remove(v1)
    return dependmap

def toposort(dependmap):
    # set of nodes with no incoming edges on the graph
    # this means no dependencies
    tailnodes = []
    for k,v in dependmap.items():
        if len(v) == 0:
            # no dependencies
            tailnodes.append(k)

    # the final sorted list
    sortedlist = []
    while len(tailnodes) > 0:
        # take a non dependent node out and put it on our sorted list
        currentnode = str(tailnodes.pop())
        sortedlist.append(currentnode)
        # find all the elements that depend on the current node
        dependants = []
        for k, v in dependmap.items():
            for v1 in v:
                if v1 == currentnode:
                    dependants.append(k)
        # for each dependant:
        for d in dependants:
            # remove this dependency
            dependmap[d].remove(currentnode)
            # if we are empty, we are sorted
            if len(dependmap[d]) == 0:
                tailnodes.append(d)

    return sortedlist

projectroot = os.environ['PROJECT_ROOT']
manifestFile = os.environ['PROJECT_MANIFEST']
outputPath = os.environ['PROJECT_CODEGEN_DIR']
buildPath = os.environ['PROJECT_BUILD_DIR']

# check the environment is set
if not projectroot:
    sys.exit(-1)
if not manifestFile:
    sys.exit(-1)
if not outputPath:
    sys.exit(-1)

outputClone = codecs.open(outputPath + "/clone.sh", 'w', 'utf-8')
outputGit = codecs.open(outputPath + "/git.sh", 'w', 'utf-8')
outputCmake = codecs.open(outputPath + "/CMakeLists.txt", 'w', 'utf-8')

manifestDom = minidom.parse(manifestFile)
remoteList = manifestDom.getElementsByTagName('remote')

remotes = {} # dictionary mapping name to fetch
for r in remoteList:
    remotes[r.attributes['name'].value] = r.attributes['fetch'].value

projectList = manifestDom.getElementsByTagName('project')

# put the projects into a list

outputClone.write("#!/bin/bash\n")
outputClone.write("source " + projectroot + "/scripts/include/common.sh\n")
outputGit.write("#!/bin/bash\n")
outputCmake.write("cmake_minimum_required(VERSION 2.8)\n")
cmakeSubDirList = []
for p in projectList:
    r = p.attributes['remote'].value
    server_path = p.attributes['name'].value
    local_path = p.attributes['path'].value
    # write the clone commands
    outputClone.write("pushd " + projectroot + " >> /dev/null\n")
    outputClone.write("clone_or_pull " + remotes[r] + "/" + server_path + " " + \
            projectroot + " " + local_path + "\n");
    outputClone.write("popd >> /dev/null\n")
    # for any generic git command other than clone
    outputGit.write("pushd " + projectroot + "/" + local_path + " >> /dev/null\n")
    outputGit.write("echo \"Repository: " + local_path + "\"\n")
    outputGit.write("git $1 \n")
    outputGit.write("popd >> /dev/null\n")
    outputGit.write("echo \"\"\n")
    # add subdirectories for cmake
    cmakeSubDirList.append(p.attributes['path'].value)

# we need to topologically sort our dependency graph for cmake
# this ensures the add_subdirectories are done the right way
deps = dependencies(projectroot, cmakeSubDirList)
sortedlist = toposort(deps)
for p in sortedlist:
    outputCmake.write("add_subdirectory(" + projectroot + "/" + p + \
            " " + buildPath + "/" + p + ")\n");
