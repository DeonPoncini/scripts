#!/bin/bash

################################################################################
# build
################################################################################

if [ -z ${PROJECT_ROOT} ] ; then
    echo "Please source open-project.sh"
    exit 1
fi

source ${PROJECT_SCRIPT_DIR}/include/common.sh

VALID_OPTIONS="cmake|clean|uninstall|help|test|serial"
VALID_TARGETS="linux-64|android"
VALID_BUILDS="debug|release"
VALID_PROJECTS="all"

DEFAULT_TARGET="linux-64"
DEFAULT_BUILD="debug"
DEFAULT_PROJECT="all"

# read up the valid projects
while read line
do
    VALID_PROJECTS="${VALID_PROJECTS}|${line}"
done < ${PROJECT_CODEGEN_DIR}/list

IFS='|' read -a ARRAY_OPTIONS <<< "$VALID_OPTIONS"
IFS='|' read -a ARRAY_TARGETS <<< "$VALID_TARGETS"
IFS='|' read -a ARRAY_BUILDS <<< "$VALID_BUILDS"
IFS='|' read -a ARRAY_PROJECTS <<< "$VALID_PROJECTS"

# map of what platforms have shared or static libraries
declare -A TARGET_SHARED_MAP=(
    ["linux-64"]="ON"
    ["android"]="OFF"
)

# map of cross compile targets
declare -A TARGET_CROSS_MAP=(
    ["linux-64"]="false"
    ["android"]="true"
)

################################################################################
# print usage
################################################################################
function usage {
    echo "Usage: build [-t $VALID_TARGETS] [-b $VALID_BUILDS] [-p $VALID_PROJECTS] [$VALID_OPTIONS]"
    exit 1
}

################################################################################
# build
# $1 build directory
# $2 cmake options
# $3 cmake projects
# $4 force cmake
################################################################################
function build {
    local build_dir=$1
    local cmake_options=$2
    local cmake_projects=$3
    local force_cmake=$4

    # order the dependencies of the project manifest
    ${PROJECT_SCRIPT_DIR}/bin/order-deps
    check_error $? "dependency ordering failed, aborting..."

    # run cmake if we need to
    if [ ! -e ${build_dir}/CMakeCache.txt ] || [ -n "${force_cmake}" ] ; then
        pushd ${build_dir} >> /dev/null
        cmake -DCMAKE_EXPORT_COMPILE_COMMANDS='ON' ${cmake_options} $PROJECT_SCRIPT_DIR/cmake
        check_error $? "cmake failed, aborting..."
        popd >> /dev/null
    fi

    local make_opts=""
    if [ $(list_contains test ${BUILD_OPTIONS[@]}) = true ] ; then
        make_opts="${make_opts} check"
    fi

    if [ $(list_contains serial ${BUILD_OPTIONS[@]}) = false ] ; then
        make_opts="${make_opts} -j8"
    fi

    if [ "$cmake_projects" = "all" ] ; then
        echo "making all"
        pushd ${build_dir} >> /dev/null
        make ${make_opts}
        check_error $? "make failed, aborting..."
        popd >> /dev/null
    else
        IFS=' ' read -a cmake_projects <<< "${cmake_projects}"
        for p in "${cmake_projects[@]}" ; do
            echo "making ${p}"
            pushd ${build_dir} >> /dev/null
            make ${make_opts} ${p}
            check_error $? "make ${p} failed, aborting..."
            popd >> /dev/null
        done
    fi

    # run make install
    pushd ${build_dir} >> /dev/null
    make install
    check_error $? "make install failed, aborting..."
    popd >> /dev/null
}

################################################################################
# argument parsing
################################################################################
BUILD_TARGETS=""
BUILD_BUILDS=""
BUILD_PROJECTS=""
while getopts ":t:b:p:" o; do
    case "${o}" in
        t)
            BUILD_TARGETS="${BUILD_TARGETS}${OPTARG},"
            ;;
        b)
            BUILD_BUILDS="${BUILD_BUILDS}${OPTARG},"
            ;;
        p)
            BUILD_PROJECTS="${BUILD_PROJECTS}${OPTARG},"
            ;;
        *)
            usage
            ;;
    esac
done
shift $((OPTIND-1))

# set the defaults if not set
if [ "${BUILD_TARGETS}" = "" ] ; then
    BUILD_TARGETS=$DEFAULT_TARGET
fi

if [ "${BUILD_BUILDS}" = "" ] ; then
    BUILD_BUILDS=$DEFAULT_BUILD
fi

if [ "${BUILD_PROJECTS}" = "" ] ; then
    BUILD_PROJECTS=$DEFAULT_PROJECT
fi

# convert comma separated options into arrays
IFS=',' read -a BUILD_TARGETS <<< "${BUILD_TARGETS%,}"
IFS=',' read -a BUILD_BUILDS <<< "${BUILD_BUILDS%,}"
IFS=',' read -a BUILD_PROJECTS <<< "${BUILD_PROJECTS%,}"

# validate
for t in "${BUILD_TARGETS[@]}" ; do
    if [ $(list_contains $t ${ARRAY_TARGETS[@]}) = false ] ; then
        echo "Invalid target $t"
        usage
    fi
done

for b in "${BUILD_BUILDS[@]}" ; do
    if [ $(list_contains $b ${ARRAY_BUILDS[@]}) = false ] ; then
        echo "Invalid build $b"
        usage
    fi
done

for p in "${BUILD_PROJECTS[@]}" ; do
    if [ $(list_contains $p ${ARRAY_PROJECTS[@]}) = false ] ; then
        echo "Invalid project $p"
        usage
    fi
done

################################################################################
# options
################################################################################
IFS=' ' read -a BUILD_OPTIONS <<< "$(parse_params $@)"

for o in "${BUILD_OPTIONS[@]}" ; do
    if [ $(list_contains $o ${ARRAY_OPTIONS[@]}) = false ] ; then
        echo "Invalid option $o"
        usage
    fi
done

# operate on options
if [ $(list_contains help ${BUILD_OPTIONS[@]}) = true ] ; then
    usage
fi

FORCE_CMAKE=$(list_contains cmake ${BUILD_OPTIONS[@]})

# build each build type for each target
for b in "${BUILD_BUILDS[@]}" ; do
    # for each target
    for t in "${BUILD_TARGETS}" ;  do

        BUILD_PATH=$PROJECT_BUILD_DIR/${b}/${t}
        INSTALL_PATH=$PROJECT_INSTALL_DIR/${b}/${t}
        SYSTEM_PATH=${PROJECT_SYSTEM_DIR}/${b}/${t}

        if [ $(list_contains clean ${BUILD_OPTIONS[@]}) = true ] ; then
            echo "****************************"
            echo " CLEANING $t [$b]"
            echo "****************************"
            rm -rf $BUILD_PATH
            rm -rf $SYSTEM_PATH
            continue
        fi

        if [ $(list_contains uninstall ${BUILD_OPTIONS[@]}) = true ] ; then
            echo "****************************"
            echo " UNINSTALLING $t [$b]"
            echo "****************************"
            rm -rf $INSTALL_PATH
            continue
        fi

        echo "****************************"
        echo " BUILDING $t [$b]"
        echo "****************************"

        # get the toolchain file
        TOOLCHAIN="${PROJECT_SCRIPT_DIR}/cmake/toolchains/${t}-toolchain.cmake"

        # setup the cmake options
        CMAKE_OPTIONS="-DCMAKE_PREFIX_PATH=${SYSTEM_PATH}"
        CMAKE_OPTIONS="${CMAKE_OPTIONS} -DCMAKE_INSTALL_PREFIX=${INSTALL_PATH}"
        CMAKE_OPTIONS="${CMAKE_OPTIONS} -DCMAKE_BUILD_TYPE=${b^}"
        CMAKE_OPTIONS="${CMAKE_OPTIONS} -DBUILD_PATH=${BUILD_PATH}"
        CMAKE_OPTIONS="${CMAKE_OPTIONS} -DCMAKE_TOOLCHAIN_FILE=${TOOLCHAIN}"
        CMAKE_OPTIONS="${CMAKE_OPTIONS} -DBUILD_SHARED_LIBS=${TARGET_SHARED_MAP["$t"]}"
        CMAKE_OPTIONS="${CMAKE_OPTIONS} -DCMAKE_CROSSCOMPILING=${TARGET_CROSS_MAP["$t"]}"
        CMAKE_OPTIONS="${CMAKE_OPTIONS} -DCROSS_TARGET=$t"

        CMAKE_PROJECTS=""
        if [ $(list_contains "all" ${BUILD_PROJECTS[@]}) = false ] ; then
            for b in ${BUILD_PROJECTS[@]} ; do
                CMAKE_PROJECTS="${CMAKE_PROJECTS} ${b}"
            done
        else
            CMAKE_PROJECTS="all"
        fi

        make_dir $BUILD_PATH
        make_dir $SYSTEM_PATH
        make_dir $INSTALL_PATH

        build "${BUILD_PATH}" "${CMAKE_OPTIONS}" "${CMAKE_PROJECTS}" "${FORCE_CMAKE}"
    done
done
